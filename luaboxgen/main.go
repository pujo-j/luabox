/*
 *    Copyright 2020 Josselin Pujo
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 *
 */

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"text/template"
)

import "golang.org/x/tools/imports"

type Import struct {
	Alias string
	Path  string
}

type Param struct {
	Name string
	Type string
}

type Func struct {
	Name    string
	Params  []string
	Outputs []string
}

func (f Func) GenCall() string {
	nOutputs := len(f.Outputs)
	nParams := len(f.Params)
	b := strings.Builder{}
	op := make([]string, nOutputs)
	for i := 1; i <= nOutputs-1; i++ {
		op[i-1] = fmt.Sprintf("o%d", i)
	}
	op[nOutputs-1] = "err"
	b.WriteString(strings.Join(op, ","))
	b.WriteString(":=")
	b.WriteString(f.Name)
	b.WriteString("(")
	ip := make([]string, nParams)
	for i := 1; i <= nParams; i++ {
		ip[i-1] = fmt.Sprintf("a%d", i)
	}
	b.WriteString(strings.Join(ip, ","))
	b.WriteString(")")
	return b.String()
}

func (f Func) GenOutputs() string {
	nOutputs := len(f.Outputs)
	out := make([]string, nOutputs)
	for i := 1; i <= nOutputs-1; i++ {
		o := f.Outputs[i-1]
		switch o {
		case "string":
			out[i-1] = genOutString(i)
		case "int":
			out[i-1] = genOutInt(i)
		case "bool":
			out[i-1] = genOutBool(i)
		default:
			out[i-1] = genOutObject(i)
		}
	}
	out[nOutputs-1] = fmt.Sprintf("return %d", nOutputs-1)
	return strings.Join(out, "\n")
}

type Data struct {
	Package string
	Imports []Import
	Funcs   []Func
}

func genOutString(idx int) string {
	return fmt.Sprintf("l.PushString(o%d)", idx)
}

func genOutInt(idx int) string {
	return fmt.Sprintf("l.PushInteger(o%d)", idx)
}

func genOutObject(idx int) string {
	return fmt.Sprintf("l.PushUserData(o%d)", idx)
}

func genOutBool(idx int) string {
	return fmt.Sprintf("l.PushBoolean(o%d)", idx)
}

func genGetString(idx int) string {
	return fmt.Sprintf("a%d := lua.CheckString(l,%d)", idx, idx)
}

func genGetInt(idx int) string {
	return fmt.Sprintf("a%d := lua.CheckInteger(l,%d)", idx, idx)
}

func genGetBool(idx int) string {
	return fmt.Sprintf("a%d := lua.CheckInteger(l,%d)!=0", idx, idx)
}

func genGetObject(idx int, t string) string {
	return fmt.Sprintf(`lua.CheckAny(l, %d)
ai%d := l.ToUserData(%d)
a%d,ok:= ai.(%s)
if !ok {
		l.PushString("Expected %s as %d parameter")
		l.Error()
		return 0
}`, idx, idx, idx, idx, t, t, idx)
}

func main() {
	file := os.Args[1]
	outFile := strings.Replace(file, ".go", "_luagen.go", -1)
	fset := token.NewFileSet()
	parseFile, err := parser.ParseFile(fset, file, nil, 0)
	if err != nil {
		panic(err)
	}
	tmplS := `// Code generated by go generate; DO NOT EDIT.
package {{.Package}}

import "github.com/Shopify/go-lua"
{{range .Imports -}}
import{{.Alias}} {{.Path}}
{{end}}
{{range .Funcs }}
func Lua{{.Name}}(l *lua.State) int { {{ range .Params}}
{{.}}{{ end }}
{{ .GenCall }}
if err != nil {
	l.PushString(err.Error())
	l.Error()
	return 0
}
{{ .GenOutputs }}
}
{{end}}

`
	d := Data{
		Package: parseFile.Name.Name,
		Imports: make([]Import, 0),
		Funcs:   make([]Func, 0),
	}
	for _, importSpec := range parseFile.Imports {
		i := Import{Path: importSpec.Path.Value}
		if importSpec.Name != nil {
			i.Alias = " " + importSpec.Name.Name
		} else {
			i.Alias = ""
		}
		d.Imports = append(d.Imports, i)
	}
	for _, decl := range parseFile.Decls {
		fd, ok := decl.(*ast.FuncDecl)
		if ok {
			if fd.Recv == nil {
				f := Func{
					Name:    fd.Name.Name,
					Params:  make([]string, 0),
					Outputs: make([]string, 0),
				}
				for idx, par := range fd.Type.Params.List {
					t, ok := par.Type.(*ast.Ident)
					if ok {
						p := Param{
							Name: par.Names[0].Name,
							Type: t.Name,
						}
						var getParam string
						switch p.Type {
						case "string":
							getParam = genGetString(idx + 1)
						case "int":
							getParam = genGetInt(idx + 1)
						case "bool":
							getParam = genGetBool(idx + 1)
						default:
							getParam = genGetObject(idx+1, p.Type)
						}
						f.Params = append(f.Params, getParam)
					} else {
						t, ok := par.Type.(*ast.SelectorExpr)
						if ok {
							s, ok := t.X.(*ast.Ident)
							if ok {
								p := Param{
									Name: par.Names[0].Name,
									Type: s.Name + "." + t.Sel.Name,
								}
								var getParam string
								switch p.Type {
								case "string":
									getParam = genGetString(idx + 1)
								case "int":
									getParam = genGetInt(idx + 1)
								case "bool":
									getParam = genGetBool(idx + 1)
								default:
									getParam = genGetObject(idx+1, p.Type)
								}
								f.Params = append(f.Params, getParam)
							}
						}
					}
				}
				if fd.Type.Results != nil {
					for _, res := range fd.Type.Results.List {
						t, ok := res.Type.(*ast.Ident)
						if ok {
							f.Outputs = append(f.Outputs, t.Name)
						}
					}
				}
				if len(f.Outputs) > 0 && f.Outputs[len(f.Outputs)-1] == "error" {
					d.Funcs = append(d.Funcs, f)
				}
			}
		}
	}
	tmpl, err := template.New("test").Parse(tmplS)
	if err != nil {
		panic(err)
	}
	sb := &bytes.Buffer{}
	err = tmpl.Execute(sb, d)
	if err != nil {
		panic(err)
	}
	processed, err := imports.Process(outFile, sb.Bytes(), nil)
	if err != nil {
		panic(err)
	}
	create, err := os.Create(outFile)
	if err != nil {
		panic(err)
	}
	_, err = create.Write(processed)
	if err != nil {
		panic(err)
	}
}
